# Self-hosted Let's Encrypt. Installing ACME server on OpenWRT

This guide has translation to [Russian language](https://habr.com/ru/articles/827206/).

I guess there are many cool solutions out there for self-hosted CA, but after some quick DYOR, I decided that [step-ca](https://smallstep.com/docs/step-ca) has everything I need at the moment.

Step-CA is a PKI core and various pluggable [provisioners](https://smallstep.com/docs/step-ca/provisioners/#authorization-scope-by-provisioner), which resemble Automated Teller Machines where humans or machines could receive a certificate after authenticating through the method this provisioner implements. In this tutorial, we are going to receive certificates in exchange for ACME challenge responses, and JWK tokens generated by `step` CLI client.

Disclaimer: The steps below are pretty invasive and do not guarantee success. It is recommended to test on a [virtualized OpenWrt](https://github.com/graysievert-lab/Homelab-010_DNS_x509CA/blob/master/110-openwrt_on_proxmox.md) first.

I'm starting right after configuring [dynamic DNS updates on my OpenWRT router](https://github.com/graysievert-lab/Homelab-010_DNS_x509CA/blob/master/120-bind_on_openwrt.md), but this guide is self-sufficient if you already have control over name resolution in your network.

## Installation

The installation process is fairly simple, but be aware that you need a fair amount (~37MiB) of free storage on your router:

```bash
$ mkdir -p /tmp/step-ca
$ cd /tmp/step-ca

$ opkg update
$ opkg install curl

$ curl -LO https://dl.smallstep.com/certificates/docs-ca-install/latest/step-ca_linux_arm64.tar.gz
$ tar -zxf step-ca_linux_arm64.tar.gz && rm step-ca_linux_arm64.tar.gz
$ mv step-ca_linux_arm64/step-ca /usr/bin
$ rm -rf step-ca_linux_arm64/
```

The next step is to download `step-cli`, which is needed for initial setup and not much used later. Let's leave it on `/tmp` and make a soft link to `/usr/bin/`. The original file will be deleted after reboot, but you can always restore it by repeating the steps below:

```bash
$ mkdir -p /tmp/step-ca
$ cd /tmp/step-ca

$ curl -LO https://dl.smallstep.com/cli/docs-ca-install/latest/step_linux_arm64.tar.gz
$ tar -zxf step_linux_arm64.tar.gz && rm step_linux_arm64.tar.gz
$ ln -s /tmp/step-ca/step_linux_arm64/bin/step /usr/bin/step
```

Now let's create a system user and group to run `step-ca` as a service later.

There are several ways to do that:

### Adding user - classic method

Add user management package and create user, group and home directory

```bash
$ opkg update
$ opkg install shadow-useradd

$ useradd --user-group --system --create-home --home-dir /etc/step-ca --shell /bin/false step
```

<details>
    <summary>**Adding user - hacky method**</summary>

NOTE: Skip this section if you already executed commands above.

Let's "simply" reuse functions from `/lib/functions.sh`

Create file `useradd.sh`

```bash
$ touch useradd.sh
$ chmod +x useradd.sh
```

Place this content into useradd.sh:

```bash
#!/bin/sh
# Source OpenWRT functions file
. /lib/functions.sh
usage() {
    echo "Usage: $0 <username> <home_directory>"
    exit 1
}
# Two non empty strings are required arguments
if [ "$#" -ne 2 ] || [ -z "$1" ] || [ -z "$2" ]; then
    usage
fi
USERNAME="$1"
HOME_DIR="$2"
SHELL="/bin/false"
# Script will choose IDs in this range
BASE_ID=900
MAX_ID=999
ID_PAIR=""

fail_fast() {
    issues_found=0
    if user_exists "$USERNAME"; then
        echo "User $USERNAME already exists with UID $(grep "^${USERNAME}:" /etc/passwd | cut -d: -f3)"
        issues_found=1
    fi
    
    if group_exists "$USERNAME"; then
        echo "Group $USERNAME already exists with GID $(grep "^${USERNAME}:" /etc/group | cut -d: -f3)"
        issues_found=1
    fi
    if [ -d "$HOME_DIR" ]; then
        echo "Home directory $HOME_DIR already exists."
        issues_found=1
    fi
    if [ "$issues_found" -gt 0 ]; then
        echo "Please fix the above. Exiting without changes."
        exit 1
    fi
}

# First pair of equal unused UID == GUID
find_available_id() {
    id="$BASE_ID"
    group_ids=$(cut -d: -f3 /etc/group)
    passwd_ids=$(cut -d: -f3 /etc/passwd)
    # Loop through IDs from BASE_ID to MAX_ID
    while [ "$id" -le "$MAX_ID" ]; do
        # Check if ID is not in /etc/group
        if ! echo "$group_ids" | grep -qw "$id"; then
            # Check if ID is also not in /etc/passwd
            if ! echo "$passwd_ids" | grep -qw "$id"; then
                # ID confirmed
                ID_PAIR="$id"
                break
            fi
        fi
        # Increment the ID
        id=$((id + 1))
    done
    # ID not found
    if [ -z "$ID_PAIR" ]; then
        echo "No available ID found in range $BASE_ID-$MAX_ID" >&2
        exit 1
    fi
}

create_group() {
        echo "Creating group $USERNAME with GID $ID_PAIR"
        group_add "$USERNAME" "$ID_PAIR"
}

create_user() {
        echo "Creating user $USERNAME with UID $ID_PAIR"
        user_add "$USERNAME" "$ID_PAIR" "$ID_PAIR" "$USERNAME" "$HOME_DIR" "$SHELL"
}

create_home_directory() {
    echo "Creating home directory $HOME_DIR"
    mkdir -p "$HOME_DIR"
    chown "$USERNAME:$USERNAME" "$HOME_DIR"
    chmod 755 "$HOME_DIR"
}

main() {
    fail_fast
    find_available_id
    create_group
    create_user
    create_home_directory
}
main
```

Now let's create a user and group:

```bash
$ ./useradd.sh step /etc/step-ca 
Creating group step with GID 900
Creating user step with UID 900
Creating home directory /etc/step-ca
```

</details>

## Bootstrapping PKI

Let's generate only the PKI without the CA configuration. That would allow us to prepare (and backup) keys first and deal with configuration later.

NOTE: Step-ca is going to use the same pass for the root CA key and intermediate CA key. That is what we need to address and set different passwords for those keys. During initialization and in later stages `step-ca` will be proposing you to use the generated password or enter your own. Not financial advice: do not use the password from your bank account.

```bash
$ export STEPPATH=/tmp/step-ca

# step ca init --pki --name="Homelab" --deployment-type standalone 
Choose a password for your CA keys.
✔ [leave empty and we'll generate one]:
✔ Password: ZbeS;.)JR`=^Jak%`)3:Xy9\NwnXTA]_
Generating root certificate... done!
Generating intermediate certificate... done!
✔ Root certificate: /tmp/step-ca/certs/root_ca.crt
✔ Root private key: /tmp/step-ca/secrets/root_ca_key
✔ Root fingerprint: cd6555dce8cfcab515223fdea99531a86d329df31d453d3d0eab4e5d185f6130
✔ Intermediate certificate: /tmp/step-ca/certs/intermediate_ca.crt
✔ Intermediate private key: /tmp/step-ca/secrets/intermediate_ca_key
```

The root key is not going to be used often. Actually, we won't keep it on OpenWRT at all. The Intermediate CA will be used more frequently so let's change the password for the intermediate CA private key:

```bash
$ step crypto change-pass /tmp/step-ca/secrets/intermediate_ca_key 
Please enter the password to decrypt /tmp/step-ca/secrets/intermediate_ca_key: 
Please enter the password to encrypt /tmp/step-ca/secrets/intermediate_ca_key: 
✔ Would you like to overwrite /tmp/step-ca/secrets/intermediate_ca_key [y/n]: y
Your key has been saved in /tmp/step-ca/secrets/intermediate_ca_key.
```

This is the right moment to back up your `root_ca_key` and `root_ca.crt` somewhere safe outside of OpenWRT.

## Configure JWK provisioner

For testing and manual certificate issuance, we would need to activate the so-called JWK provisioner. At this point the easiest way to do that is to run `step ca init` command again with some additional options, and then substitute the certificates and keys it generated with the ones we already have.

WARNING: The password you choose in this step will be a provisioner password (the third one by count). Don't use your root CA or intermediate CA passwords from the previous steps!

We are going to use port `8443` for authority as `433` is used by `uhttpd` to serve the router's LuCi web UI.

The command below assumes that the IP address of the router on the LAN side is `192.168.1.1` and its FQDN is `openwrt.lan`. Also this time we are going to store configuration permanently in `/etc/step-ca`:

```bash
# export STEPPATH=/etc/step-ca

$ step ca init \
--name="Homelab CA" \
--dns="openwrt.lan" \
--dns="192.168.1.1" \
--address=":8443" \
--provisioner="JWK@openwrt.lan" \
--deployment-type standalone

Choose a password for your CA keys and first provisioner.
✔ [leave empty and we'll generate one]: XXXXXX 
Generating root certificate... done!
Generating intermediate certificate... done!
✔ Root certificate: /etc/step-ca/certs/root_ca.crt
✔ Root private key: /etc/step-ca/secrets/root_ca_key
✔ Root fingerprint: 5e4390f0581c479b7e36db4a3642d128f1160d745708e64f588c5f3dabaabd2f
✔ Intermediate certificate: /etc/step-ca/certs/intermediate_ca.crt
✔ Intermediate private key: /etc/step-ca/secrets/intermediate_ca_key
✔ Database folder: /etc/step-ca/db
✔ Default configuration: /etc/step-ca/config/defaults.json
✔ Certificate Authority configuration: /etc/step-ca/config/ca.json
Your PKI is ready to go. To generate certificates for individual services see 'step help ca'.
```

As one may see now in addition to keys it has generated database and configuration files.

Let's remove generated certs and keys and substitute them with the ones we already have.

```bash
$ rm /etc/step-ca/certs/root_ca.crt
$ rm /etc/step-ca/secrets/root_ca_key
$ rm /etc/step-ca/certs/intermediate_ca.crt
$ rm /etc/step-ca/secrets/intermediate_ca_key

$ mv /tmp/step-ca/secrets/intermediate_ca_key /etc/step-ca/secrets/
$ mv /tmp/step-ca/certs/intermediate_ca.crt /etc/step-ca/certs/
$ mv /tmp/step-ca/certs/root_ca.crt  /etc/step-ca/certs/
```

Also, let's delete `root_ca_key`, which by now you should have saved somewhere safe outside of OpenWRT

```bash
$ rm /tmp/step-ca/secrets/root_ca_key
```

Each time our CA spins up we would need to enter the password for the intermediate CA key. Which is something we want to avoid. Step-ca has the option to address this by loading the key password from a file.

Let's just paste the intermediate CA key password into a file (after pasting use `ctrl+d` on a new line):

```bash
$ cat -> /etc/step-ca/secrets/intermediate_ca_key_pass
```

Word of caution: This approach is OK if you run `step-ca` in a container on safe infrastructure. But on bare metal, it is just slightly better than resetting the key password to an empty string.

Change ownership of files to `step:step` user:

```bash
$ chown -R step:step /etc/step-ca
```

Now let's start the CA as step user and make sure it's running properly. As OpenWRT does not provide `sudo` out of the box, let's use `start-stop-daemon` as a substitute:

```bash
$ start-stop-daemon -S \
-c step:step \
-x /usr/bin/step-ca -- \
/etc/step-ca/config/ca.json \
--password-file /etc/step-ca/secrets/intermediate_ca_key_pass

badger 2024/07/02 11:03:14 INFO: All 0 tables opened in 13ms
2024/07/02 11:03:14 Building new tls configuration using step-ca x509 Signer Interface
2024/07/02 11:03:16 Starting Smallstep CA/0.26.2 (linux/arm64)
2024/07/02 11:03:16 Documentation: https://u.step.sm/docs/ca
2024/07/02 11:03:16 Community Discord: https://u.step.sm/discord
2024/07/02 11:03:16 Config file: /etc/step-ca/config/ca.json
2024/07/02 11:03:16 The primary server URL is https://openwrt.lan:8443
2024/07/02 11:03:16 Root certificates are available at https://openwrt.lan:8443/roots.pem
2024/07/02 11:03:16 Additional configured hostnames: 192.168.1.1
2024/07/02 11:03:16 X.509 Root Fingerprint: cd6555dce8cfcab515223fdea99531a86d329df31d453d3d0eab4e5d185f6130
2024/07/02 11:03:16 Serving HTTPS on :8443 ...
```

As one can see in `X.509 Root Fingerprint:` the fingerprint corresponds to the keys we generated first. BTW we need it for the next step.

In another terminal, let's generate a test certificate for localhost. First, initialize the environment to use the CA commands:

```bash
$ unset STEPPATH
$ step ca bootstrap \
--ca-url "https://openwrt.lan:8443" \
--fingerprint cd6555dce8cfcab515223fdea99531a86d329df31d453d3d0eab4e5d185f6130
The root certificate has been saved in /root/.step/certs/root_ca.crt.
The authority configuration has been saved in /root/.step/config/defaults.json.
```

Now Let's generate a new private key and certificate with `CN="openwrt.lan"` signed by our CA. You will be asked for the provisioner's password we created in the second step.

```bash
$ step ca certificate \
"openwrt.lan" \
localhost.crt localhost.key \
--san="openwrt.lan" \
--san="192.168.1.1"

✔ Provisioner: JWK@openwrt.lan (JWK) [kid: sNXCP0f2uaMH3Nvj9wFHPwzQiSxQfSKVwLqO_73kstE]
Please enter the password to decrypt the provisioner key: 
✔ CA: https://openwrt.lan:8443
✔ Certificate: localhost.crt
✔ Private Key: localhost.key
```

Let's see what got:

```bash
$ step certificate inspect localhost.crt --format=text 

Certificate:
    Data:
...
    Signature Algorithm: ECDSA-SHA256
        Issuer: O=Homelab,CN=Homelab Intermediate CA
        Validity
            Not Before: Jul 2 11:09:15 2024 UTC
            Not After : Jul 3 11:10:15 2024 UTC
        Subject: CN=openwrt.lan
...
        X509v3 extensions:
            X509v3 Key Usage: critical
                Digital Signature
            X509v3 Extended Key Usage:
                Server Authentication, Client Authentication
...
            X509v3 Subject Alternative Name:
                DNS:openwrt.lan
                IP Address:192.168.1.1
            X509v3 Step Provisioner:
                Type: JWK
                Name: JWK@openwrt.lan
                CredentialID: sNXCP0f2uaMH3Nvj9wFHPwzQiSxQfSKVwLqO_73kstE
....
```

Cool, we now have a certificate for our router for the whole day! We need to automate certificate provisioning but first let's run `step-ca` as a service.
Now stop the `step-ca` running in another terminal.

## Launching step-ca as a service on OpenWRT

To launch `step-ca` as a service we need to create `/etc/init.d/step-ca` script:

```bash
$ touch /etc/init.d/step-ca
$ chmod +x /etc/init.d/step-ca
```

with the following content:

```bash
#!/bin/sh /etc/rc.common
START=99
USE_PROCD=1
SERVICE_COMMAND='/usr/bin/step-ca'
SERVICE_CONFIG='/etc/step-ca/config/ca.json'
SERVICE_ARGS='--password-file /etc/step-ca/secrets/intermediate_ca_key_pass'
SERVICE_PIDFILE=/var/run/step-ca.pid
SERVICE_USER=step
SERVICE_GROUP=step
start_service() {
    procd_open_instance
    procd_set_param command $SERVICE_COMMAND 
    procd_append_param command $SERVICE_CONFIG
    procd_append_param command $SERVICE_ARGS
    procd_set_param user $SERVICE_USER
    procd_set_param group $SERVICE_GROUP
    procd_set_param pidfile $SERVICE_PIDFILE
    procd_set_param stdout 1
    procd_set_param stderr 1
    procd_set_param file $SERVICE_CONFIG
    procd_set_param respawn
    procd_close_instance
}
reload_service() {
        procd_send_signal step-ca
}
```

Let's test. In another ssh session launch syslog monitor

```bash
$ logread -f 
```

Then one may entertain with the following commands:

```bash
$ /etc/init.d/step-ca start
$ /etc/init.d/step-ca stop
$ /etc/init.d/step-ca restart
$ /etc/init.d/step-ca status
$ /etc/init.d/step-ca reload
```

Let's enable the service on boot:

```bash
$ /etc/init.d/step-ca enable
```

And verify it's enabled:

```bash
$ ls -l /etc/rc.d/ | grep step-ca
lrwxrwxrwx  1  root root  17 Jul  2  11:20  S99step-ca -> ../init.d/step-ca
```

Now we are ready to spin up our own Let's Encrypt.

## Configure ACME provisioner

Let's add to our certificate authority the ACME provisioner:

```bash
$ export STEPPATH=/etc/step-ca

$ step ca provisioner add ACME@openwrt.lan --type ACME
✔ CA Configuration: /etc/step-ca/config/ca.json
Success! Your `step-ca` config has been updated. To pick up the new configuration SIGHUP (kill -1 <pid>) or restart the step-ca process.
```

Reload `step-ca` service to apply the new config

```bash
$ /etc/init.d/step-ca reload
```

For testing we need to use some host connected to our router on LAN side.

First, let's check APIs could be reached:

```bash
[rocky@test ~]$ curl -s --insecure https://openwrt.lan:8443/acme/ACME@openwrt.lan/directory | jq . 
{
  "newNonce": "https://openwrt.lan:8443/acme/ACME@openwrt.lan/new-nonce",
  "newAccount": "https://openwrt.lan:8443/acme/ACME@openwrt.lan/new-account",
  "newOrder": "https://openwrt.lan:8443/acme/ACME@openwrt.lan/new-order",
  "revokeCert": "https://openwrt.lan:8443/acme/ACME@openwrt.lan/revoke-cert",
  "keyChange": "https://openwrt.lan:8443/acme/ACME@openwrt.lan/key-change"
}
```

NOTE: URL part `ACME@openwrt.lan` is case-sensitive. It should be exactly the same as it was entered in the `step ca provisioner add` command.

Now let's add to the system the root certificate from our CA to avoid using `--insecure` option for TLS connections:

```bash
[rocky@test ~]$ curl -s --insecure https://openwrt.lan:8443/roots.pem | tee - openwrt.crt 
[rocky@test ~]$ sudo mv openwrt.crt /etc/pki/ca-trust/source/anchors/openwrt.crt
[rocky@test ~]$ sudo update-ca-trust extract
```

Note: here's a [nice summary of how to install root certificates on a variety of Linux distributions and OSes](https://github.com/millermatt/osca?tab=readme-ov-file#operating-system-cert-management)

Let's check if we now trust our CA and if TLS works:

```bash
[rocky@test ~]$ curl https://openwrt.lan:8443/roots
```

You should see no errors on Linux hosts at this point.

Now fetch `acme.sh`

```bash
[rocky@test ~]$ curl -LO https://raw.githubusercontent.com/acmesh-official/acme.sh/master/acme.sh

[rocky@test ~]$ chmod +x acme.sh
```

and let's test the acme challenge types `step-ca` supports.

### Testing (http-01) Challenge

For `http-01` challenge we would need to run a web server on port `80`. The easiest way is just to ensure `acme.sh` will find `socat` on the system:

```bash
[rocky@test ~]$ sudo dnf install socat -y
```

Also you may need to open port `80` in your firewall

```bash
[rocky@test ~]$ sudo firewall-cmd --permanent --add-service=http
[rocky@test ~]$ sudo firewall-cmd --reload
```

Now let's request a certificate with hostname and IP address as Subject Alternative Names (SAN). As port `80` is involved it is just easier to run the command with `sudo`:

```bash
[rocky@test ~]$ sudo ./acme.sh --force --issue --standalone \
--server https://openwrt.lan:8443/acme/ACME@openwrt.lan/directory \
-d $(ip -4 addr show eth0 | awk '/inet/ {split($2, a, "/"); print a[1]}') \
-d $(hostname -f)

[] Using CA: https://openwrt.lan:8443/acme/ACME@openwrt.lan/directory
[] Standalone mode.
[] Standalone mode.
[] Create account key ok.
[] Registering account: https://openwrt.lan:8443/acme/ACME@openwrt.lan/directory
[] Registered
[] ACCOUNT_THUMBPRINT='NYf5qbz9bWo_lBNytbgDaaFCv8MyUHpukWncBvZY7_E'
[] Creating domain key
[] The domain key is here: /root/.acme.sh/192.168.1.179_ecc/192.168.1.179.key
[] Multi domain='IP:192.168.1.179,DNS:test.lan'
[] Getting webroot for domain='192.168.1.179'
[] Getting webroot for domain='test.lan'
[] Verifying: 192.168.1.179
[] Standalone mode server
[] Success
[] Verifying: test.lan
[] Standalone mode server
[] Success
[] Verify finished, start to sign.
[] Lets finalize the order.
[] Le_OrderFinalize='https://openwrt.lan:8443/acme/ACME@openwrt.lan/order/zYqWGaDfUJX3EaIxitPCFnGxvnKu9aJ6/finalize'
[] Downloading cert.
[] Le_LinkCert='https://openwrt.lan:8443/acme/ACME@openwrt.lan/certificate/X1jfcvk9jxso0KBJWDRYYceNE3TkKM3J'
[] Cert success.
-----BEGIN CERTIFICATE-----
MIIB7jCCAZWgAwIBAgIRAMd9th9qDVmO3W1592vVCDEwCgYIKoZIzj0EAwIwNDEQ
MA4GA1UEChMHSG9tZWxhYjEgMB4GA1UEAxMXSG9tZWxhYiBJbnRlcm1lZGlhdGUg
Q0EwHhcNMjQwNzAyMTIyOTIyWhcNMjQwNzAzMTIzMDIyWjAAMFkwEwYHKoZIzj0C
AQYIKoZIzj0DAQcDQgAEiW9mGrhg7ENqXP2c1xFRQLzBEFiiKk8hYD8nQ89Yv8Lp
pOjLQCZtE0hwtyx1bquxUjToO9J5jCef9A+Bwy8luqOBuzCBuDAOBgNVHQ8BAf8E
BAMCB4AwHQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsGAQUFBwMCMB0GA1UdDgQWBBSr
Alsat1jF0nWnyyy5BrGNJJV0VDAfBgNVHSMEGDAWgBQ/JWh0aHYV//iBsDVMo8jN
1kWpeDAcBgNVHREBAf8EEjAQggh0ZXN0LmxhbocEwKgBszApBgwrBgEEAYKkZMYo
QAEEGTAXAgEGBBBBQ01FQG9wZW53cnQubGFuBAAwCgYIKoZIzj0EAwIDRwAwRAIg
atUHqsKBI0X331v4raTjMGD4yqW2DNFaMOjb455zMmYCIGi9402P30gb+8uIdZtk
y+OK2HMpRjoivujbaIG45qVi
-----END CERTIFICATE-----
[] Your cert is in: /root/.acme.sh/192.168.1.179_ecc/192.168.1.179.cer
[] Your cert key is in: /root/.acme.sh/192.168.1.179_ecc/192.168.1.179.key
[] The intermediate CA cert is in: /root/.acme.sh/192.168.1.179_ecc/ca.cer
[] And the full chain certs is there: /root/.acme.sh/192.168.1.179_ecc/fullchain.cer
```

Let's see the certificate's details:

```bash
[rocky@test ~]$ sudo openssl x509 --noout --text -in /root/.acme.sh/192.168.1.179_ecc/192.168.1.179.cer

Certificate:
    Data:
...
        Signature Algorithm: ecdsa-with-SHA256 
        Issuer: O = Homelab, CN = Homelab Intermediate CA
        Validity
            Not Before: Jul  2 12:29:22 2024 GMT
            Not After : Jul  3 12:30:22 2024 GMT
        Subject: 
...
        X509v3 extensions: 
            X509v3 Key Usage: critical
                Digital Signature
            X509v3 Extended Key Usage: 
                TLS Web Server Authentication, TLS Web Client Authentication
...
            X509v3 Subject Alternative Name: critical 
                DNS:test.lan, IP Address:192.168.1.179
            1.3.6.1.4.1.37476.9000.64.1: 
                0......ACME@openwrt.lan.. 
...
```

Let's proceed to `tls-alpn-01` chalenge.

### Testing TLS ALPN challenge (tls-alpn-01)

You may need to open port `443` in your firewall:

```bash
[rocky@test ~]$ sudo firewall-cmd --permanent --add-service=https
[rocky@test ~]$ sudo firewall-cmd --reload
```

Let's request a certificate with the same SANs as we did earlier, but this time using `--alpn` option:

```bash
[rocky@test ~]$ sudo ./acme.sh --force --issue --alpn \
--server https://openwrt.lan:8443/acme/ACME@openwrt.lan/directory \
-d $(ip -4 addr show eth0 | awk '/inet/ {split($2, a, "/"); print a[1]}') \
-d $(hostname -f)

[] Using CA: https://openwrt.lan:8443/acme/ACME@openwrt.lan/directory
[] Standalone alpn mode.
[] Standalone alpn mode.
[] Multi domain='IP:192.168.1.179,DNS:test.lan'
[] Getting webroot for domain='192.168.1.179'
[] Getting webroot for domain='test.lan'
[] Verifying: 192.168.1.179
[] Starting tls server.
[] Success
[] Verifying: test.lan
[] Starting tls server.
[] Success
[] Verify finished, start to sign.
[] Lets finalize the order.
[] Le_OrderFinalize='https://openwrt.lan:8443/acme/ACME@openwrt.lan/order/AShNFavQaGD6NUQzAloClC25U7FpiaI5/finalize'
[] Downloading cert.
[] Le_LinkCert='https://openwrt.lan:8443/acme/ACME@openwrt.lan/certificate/bSqEfweMCa8Zrm0ACa9RvBR8m1EXYv72'
[] Cert success.
-----BEGIN CERTIFICATE-----
MIIB7jCCAZSgAwIBAgIQCGxsU1/Od7+w9pOhGC4stTAKBggqhkjOPQQDAjA0MRAw
DgYDVQQKEwdIb21lbGFiMSAwHgYDVQQDExdIb21lbGFiIEludGVybWVkaWF0ZSBD
QTAeFw0yNDA3MDIxMjUyNTRaFw0yNDA3MDMxMjUzNTRaMAAwWTATBgcqhkjOPQIB
BggqhkjOPQMBBwNCAASJb2YauGDsQ2pc/ZzXEVFAvMEQWKIqTyFgPydDz1i/wumk
6MtAJm0TSHC3LHVuq7FSNOg70nmMJ5/0D4HDLyW6o4G7MIG4MA4GA1UdDwEB/wQE
AwIHgDAdBgNVHSUEFjAUBggrBgEFBQcDAQYIKwYBBQUHAwIwHQYDVR0OBBYEFKsC
Wxq3WMXSdafLLLkGsY0klXRUMB8GA1UdIwQYMBaAFD8laHRodhX/+IGwNUyjyM3W
Ral4MBwGA1UdEQEB/wQSMBCCCHRlc3QubGFuhwTAqAGzMCkGDCsGAQQBgqRkxihA
AQQZMBcCAQYEEEFDTUVAb3BlbndydC5sYW4EADAKBggqhkjOPQQDAgNIADBFAiEA
ubZ2PGzXa/s3QNCalEzPBP90yChTz68WOKDcBOWRaz8CIHiUZijOd4Z9oiR1/nLq
L4CspCrIZjTSalfjoGRJ2Jhp
-----END CERTIFICATE-----
[] Your cert is in: /root/.acme.sh/192.168.1.179_ecc/192.168.1.179.cer
[] Your cert key is in: /root/.acme.sh/192.168.1.179_ecc/192.168.1.179.key
[] The intermediate CA cert is in: /root/.acme.sh/192.168.1.179_ecc/ca.cer
[] And the full chain certs is there: /root/.acme.sh/192.168.1.179_ecc/fullchain.cer
```

Success!  

### Testing DNS Challenge (dns-01)

DISCLAIMER: As I have just [configured self-hosted private DNS zone with dynamic updates](https://github.com/graysievert-lab/Homelab-010_DNS_x509CA/blob/master/120-bind_on_openwrt.md) I am going to use `dns_nsupdate` hook for `acme.sh`. If you prefer some DNS provider - please check `acme.sh` [integrations](https://github.com/acmesh-official/acme.sh/wiki/dnsapi) for instructions.

Let's download `dns_nsupdate` DNS hook:

```bash
[rocky@test ~]$ curl -L --create-dirs -o dnsapi/dns_nsupdate.sh https://raw.githubusercontent.com/acmesh-official/acme.sh/master/dnsapi/dns_nsupdate.sh
```

For the sake of this test I'm going to use the TSIG key created earlier:

```bash
[rocky@test ~]$ cat <<EOK> keys.conf
key "tsig-key" {
        algorithm hmac-sha256;
        secret "HAyLN66//YxVF2lrZ6kSZK4TZEpV7WMvzYnNUQ0BvEo=";
};
EOK
```

We need to populate some data about our DNS server into environment variables for `dns_nsupdate` hook. Variables one should use are: `NSUPDATE_SERVER`, `NSUPDATE_SERVER_PORT`, `NSUPDATE_KEY`, and `NSUPDATE_ZONE`. Our case is pretty standard so we need to set just a few:

```bash
$ export NSUPDATE_SERVER="openwrt.lan"
$ export NSUPDATE_KEY="/home/rocky/keys.conf"
```

By default `acme.sh` is trying to check the emergence of the requested TXT record by querying major public DNS providers.  As our DNS server is a private one, we need to launch `acme.sh` with the `--dnssleep=<int>` option, which will force it to wait for `<int>` seconds before polling the default DNS server instead of public DNS.

With this challenge type we won't be able to use IP as SAN, so let's ask for a wildcard instead:

```bash
[rocky@test ~]$ ./acme.sh --force --issue --dns dns_nsupdate --dnssleep 0 \
--server https://openwrt.lan:8443/acme/ACME@openwrt.lan/directory \
-d $(hostname -f) \
-d *.$(hostname -f)

[] Using CA: https://openwrt.lan:8443/acme/ACME@openwrt.lan/directory
[] Multi domain='DNS:test.lan,DNS:*.test.lan'
[] Getting webroot for domain='test.lan'
[] Getting webroot for domain='*.test.lan'
[] Adding txt value: klj5Ewi9WBRJe3qDw6MMYuHcOScy7WJxhRFj-NAlQbE for domain:  _acme-challenge.test.lan
[] adding _acme-challenge.test.lan. 60 in txt "klj5Ewi9WBRJe3qDw6MMYuHcOScy7WJxhRFj-NAlQbE"
[] The txt record is added: Success.
[] Adding txt value: J-Td2g5phdsjapXEMdIKlD-kJdPbzJmKlqhYxri35V0 for domain:  _acme-challenge.test.lan
[] adding _acme-challenge.test.lan. 60 in txt "J-Td2g5phdsjapXEMdIKlD-kJdPbzJmKlqhYxri35V0"
[] The txt record is added: Success.
[] Sleep 0 seconds for the txt records to take effect
[] Verifying: test.lan
[] Success
[] Verifying: *.test.lan
[] Success
[] Removing DNS records.
[] Removing txt: klj5Ewi9WBRJe3qDw6MMYuHcOScy7WJxhRFj-NAlQbE for domain: _acme-challenge.test.lan
[] removing _acme-challenge.test.lan. txt
[] Removed: Success
[] Removing txt: J-Td2g5phdsjapXEMdIKlD-kJdPbzJmKlqhYxri35V0 for domain: _acme-challenge.test.lan
[] removing _acme-challenge.test.lan. txt
[] Removed: Success
[] Verify finished, start to sign.
[] Lets finalize the order.
[] Le_OrderFinalize='https://openwrt.lan:8443/acme/ACME@openwrt.lan/order/FO5Jl80UWqfNI3oQkapt7wv2U2rOP3F8/finalize'
[] Downloading cert.
[] Le_LinkCert='https://openwrt.lan:8443/acme/ACME@openwrt.lan/certificate/PcJd1MPhm1quJPCYrYm8m5UOJVVjDPGF'
[] Cert success.
-----BEGIN CERTIFICATE-----
MIICBTCCAaqgAwIBAgIQH+jtwcPGB55FOSejBblXnDAKBggqhkjOPQQDAjA0MRAw
DgYDVQQKEwdIb21lbGFiMSAwHgYDVQQDExdIb21lbGFiIEludGVybWVkaWF0ZSBD
QTAeFw0yNDA3MDIxNTUwMjRaFw0yNDA3MDMxNTUxMjRaMBMxETAPBgNVBAMTCHRl
c3QubGFuMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEiGQ65642wyOn5kdzlGTM
kwi7/9KnRl6wLGOJ1hPGC0CE5FG4G9MpnyfuFfndL+4H3UZzIP0oN1D4DCoPj5kj
gaOBvjCBuzAOBgNVHQ8BAf8EBAMCB4AwHQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsG
AQUFBwMCMB0GA1UdDgQWBBQqnem/GMhwtJVGRY6wn8ALxAYswjAfBgNVHSMEGDAW
gBQ/JWh0aHYV//iBsDVMo8jN1kWpeDAfBgNVHREEGDAWggoqLnRlc3QubGFuggh0
ZXN0LmxhbjApBgwrBgEEAYKkZMYoQAEEGTAXAgEGBBBBQ01FQG9wZW53cnQubGFu
BAAwCgYIKoZIzj0EAwIDSQAwRgIhAIp5TAMCK1RxiZKBELENjMPRwP+5kRJDl3dD
aDk1gxbxAiEA34ARTiq8HXB+XAqpgKk++YP4ZjpKWOYr+2+sGt5gro4=
-----END CERTIFICATE-----
[] Your cert is in: /home/rocky/.acme.sh/test.lan_ecc/test.lan.cer
[] Your cert key is in: /home/rocky/.acme.sh/test.lan_ecc/test.lan.key
[] The intermediate CA cert is in: /home/rocky/.acme.sh/test.lan_ecc/ca.cer
[] And the full chain certs is there: /home/rocky/.acme.sh/test.lan_ecc/fullchain.cer
```

Let's see the certificate's details:

```bash
[rocky@test ~]$ openssl x509 --noout --text -in /home/rocky/.acme.sh/test.lan_ecc/test.lan.cer
Certificate:
    Data:
...
        Signature Algorithm: ecdsa-with-SHA256
        Issuer: O = Homelab, CN = Homelab Intermediate CA
        Validity
            Not Before: Jul  2 15:50:24 2024 GMT
            Not After : Jul  3 15:51:24 2024 GMT
        Subject: CN = test.lan
...
        X509v3 extensions:
            X509v3 Key Usage: critical
                Digital Signature
            X509v3 Extended Key Usage: 
                TLS Web Server Authentication, TLS Web Client Authentication
...
            X509v3 Subject Alternative Name: 
                DNS:*.test.lan, DNS:test.lan
            1.3.6.1.4.1.37476.9000.64.1: 
                0......ACME@openwrt.lan..
...
```

Just out of curiosity let's peek into DNS server logs:

```text
tsig-key: updating zone 'lan/IN': adding an RR at '_acme-challenge.test.lan' TXT "klj5Ewi9WBRJe3qDw6MMYuHcOScy7WJxhRFj-NAlQbE"
...
tsig-key: updating zone 'lan/IN': adding an RR at '_acme-challenge.test.lan' TXT "J-Td2g5phdsjapXEMdIKlD-kJdPbzJmKlqhYxri35V0"
...
tsig-key: updating zone 'lan/IN': deleting rrset at '_acme-challenge.test.lan' TXT
...
tsig-key: updating zone 'lan/IN': deleting rrset at '_acme-challenge.test.lan' TXT
```

This concludes the setup of the ACME provisioner, though there are a few things left to address.

## Certificates tuning

At his moment `/etc/step-ca/config/ca.json` should look similar to this :

```JavaScript
{
    "root": "/etc/step-ca/certs/root_ca.crt",
    "federatedRoots": null,
    "crt": "/etc/step-ca/certs/intermediate_ca.crt",
    "key": "/etc/step-ca/secrets/intermediate_ca_key",
    "address": ":8443",
    "insecureAddress": "",
    "dnsNames": [
            "openwrt.lan",
            "192.168.1.1"
    ],
    "logger": {
            "format": "text"
    },
    "db": {
            "type": "badgerv2",
            "dataSource": "/etc/step-ca/db",
            "badgerFileLoadingMode": ""
    },
    "authority": {
            "provisioners": [
                    {
                            "type": "JWK",
                            "name": "JWK@openwrt.lan",
                            "key": { ... },
                            "encryptedKey": " ... "
                    },
                    {
                            "type": "ACME",
                            "name": "ACME@openwrt.lan",
                            "claims": {
                                    "enableSSHCA": true,
                                    "disableRenewal": false,
                                    "allowRenewalAfterExpiry": false,
                                    "disableSmallstepExtensions": false
                            },
                            "options": {
                                    "x509": {},
                                    "ssh": {}
                            }
                    }
            ],
            "template": {},
            "backdate": "1m0s"
    },
    "tls": { ... },
    "commonName": "Step Online CA"
}
```

Now let's tweak few things:

- Adjust certificates subject field
- Adjust validity of certificates
- Include `CRLDistributionPoints` extension, to make curl on windows happy

### Adjust certificates subject field

At the moment there is not much information in the certificate's subject field. Making something appear there is simple - we just need to populate the `authority.template` dictionary:

```JavaScript
... 
  "authority": {
...
            "template":{
                "Country": "AQ",
                "Province": "South Pole",
                "Locality": "Amundsen-Scott South Pole Station",
                "Organization": "Homelab",
                "OrganizationalUnit": "Homelab cluster"
                },
}
...
```

and reload config

```bash
$ /etc/init.d/step-ca reload
```

Note: Technically it should not matter what is entered in the Country field. Though some systems perform validation against `ISO 3166-1 alpha-2` codes, to be on the safe side it is advised to pick something from the [list](https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes)

### Adjust validity of certificates

By default, `step-ca` does not create certificates with a validity of more than 24 hours. For example, this will fail:

```bash
[rocky@test ~]$ ./acme.sh --force --issue --dns dns_nsupdate --dnssleep 0 \
--server https://openwrt.lan:8443/acme/ACME@openwrt.lan/directory \
-d $(hostname -f) \
--valid-to  "+25h"

...
[] Sign failed, finalize code is not 200.
...
```

Such a narrow time window might be an issue for automation tools that might have a minimum refresh rate equal to one day.

Each provisioner in the `authority.provisioners[]` list and `authority` itself might have the `claims` dictionary that governs the validation of the certificate's requested options. A full list is available [here](https://smallstep.com/docs/step-ca/configuration/#configuration-options) but for our task, we are interested in:

- `maxTLSCertDuration`: do not allow certificates with a duration greater than this value.
- `defaultTLSCertDuration`: if no certificate validity period is specified, use this value.

Let's configure our CA in a way that our provisioner `JWK@openwrt.lan` for manual issuance of certificates would be able to produce a certificate with a validity up to `8765h` (~1 year):

```JavaScript
"provisioners": [ 
    {
     "type": "JWK", 
     "name": "JWK@openwrt.lan", 
     "claims": { 
         "maxTLSCertDuration": "8765h" 
     },
....
```

and our provisioner `ACME@openwrt.lan` for automated issuance of certificates is defaulted to 2 days certificate validity which is also the maximum possible value:

```JavaScript
"provisioners": [
...
   {
    "type": "ACME",
    "name": "ACME@openwrt.lan",
    "claims": {
      ...
      "maxTLSCertDuration": "48h",
      "defaultTLSCertDuration": "48h",
      ...
    },
...
```

Now `/etc/step-ca/config/ca.json` should look like:

```JavaScript
{
    "root": "/etc/step-ca/certs/root_ca.crt",
    "federatedRoots": null,
    "crt": "/etc/step-ca/certs/intermediate_ca.crt",
    "key": "/etc/step-ca/secrets/intermediate_ca_key",
    "address": ":8443",
    "insecureAddress": "",
    "dnsNames": [
            "openwrt.lan",
            "192.168.1.1"
    ],
    "logger": {
            "format": "text"
    },
    "db": {
            "type": "badgerv2",
            "dataSource": "/etc/step-ca/db",
            "badgerFileLoadingMode": ""
    },
    "authority": {
            "provisioners": [
                    {
                            "type": "JWK",
                            "name": "JWK@openwrt.lan",
                            "claims": {
                                "maxTLSCertDuration": "8765h"
                            },
                            "key": {...},
                            "encryptedKey": "..."
                    },
                    {
                            "type": "ACME",
                            "name": "ACME@openwrt.lan",
                            "claims": {
                                    "enableSSHCA": true,
                                    "disableRenewal": false,
                                    "allowRenewalAfterExpiry": false,
                                    "disableSmallstepExtensions": false,
                                    "maxTLSCertDuration": "48h",
                                    "defaultTLSCertDuration": "48h"
                            },
                            "options": {
                                    "x509": {},
                                    "ssh": {}
                            }
                    }
            ],
            "template": {
                "Country": "AQ",
                "Province": "South Pole",
                "Locality": "Amundsen-Scott South Pole Station",
                "Organization": "Homelab",
                "OrganizationalUnit": "Homelab cluster"
                },
            "backdate": "1m0s"
    },
    "tls": {...},
    "commonName": "Step Online CA"
}
```

Reload the service

```bash
$ /etc/init.d/step-ca reload
```

and test ACME by requesting a certificate with a validity of 2 days:

```bash
[rocky@test ~]$ ./acme.sh --force --issue --dns dns_nsupdate --dnssleep 0 \ 
--server https://openwrt.lan:8443/acme/ACME@openwrt.lan/directory \
-d $(hostname -f) \
--valid-to  "+2d"

...
[] Cert success.
...
```

## Adding `CRLDistributionPoints` extension to certificates

On Windows even if we add our CA to the trust store with the following commands:

```powershell
> curl -k -LO https://openwrt.lan:8443/roots.pem
> certutil -addstore -enterprise -f "Root" roots.pem
```

some versions of curl for Windows might produce the error below if we try to query any URL, that is being served using a leaf certificate issued by our CA:

```powershell
curl: (35) schannel: next InitializeSecurityContext failed: CRYPT_E_NO_REVOCATION_CHECK (0x80092012) - The revocation function was unable to check revocation for the certificate.
```

In order to mitigate such behavior we need to enable CRL (Certificate Revocation Lists) feature for our provisioners.

We will start an unsecured `crl` http endpoint on port `8080` in OpenWRT (typically it would be a classic `80`, but it is already used by LuCi webUI) and configure CA to add an X509v3 extension into certificates our provisioners generate.

In `/etc/step-ca/config/ca.json` change `"insecureAddress"` and add `"crl"` dictionary

```JavaScript
{
...
    "insecureAddress": ":8080",
    "crl": {
        "enabled": true,
        "generateOnRevoke": true,
        "idpURL": "http://openwrt.lan:8080/crl" 
    },
...
}
```

Now create a custom template file for our certificates:

```bash
mkdir -p /etc/step-ca/templates/x509
touch /etc/step-ca/templates/x509/leaf-crl.tpl
chown -R step:step /etc/step-ca/templates/x509
```

and simply extend the [default template](https://github.com/smallstep/crypto/blob/162770cad29063385cb768b0191814e4c6a94e45/x509util/templates.go#L98) with the `"crlDistributionPoints": ["http://openwrt.lan:8080/crl"]`:

```bash
cat <<EOF> /etc/step-ca/templates/x509/leaf-crl.tpl
{
	"subject": {{ toJson .Subject }},
	"sans": {{ toJson .SANs }},
{{- if typeIs "*rsa.PublicKey" .Insecure.CR.PublicKey }}
	"keyUsage": ["keyEncipherment", "digitalSignature"],
{{- else }}
	"keyUsage": ["digitalSignature"],
{{- end }}
	"extKeyUsage": ["serverAuth", "clientAuth"],
	"crlDistributionPoints": ["http://openwrt.lan:8080/crl"]
}
EOF
```

Now in `/etc/step-ca/config/ca.json` for each element in `authority.provisioners[]`  we need to configure `options.x509` to contain `"templateFile": "/etc/step-ca/templates/x509/leaf-crl.tpl"`:

```JavaScript
...
"options": {
    "x509": {
        "templateFile": "/etc/step-ca/templates/x509/leaf-crl.tpl"
    },
...
}
...
```

Eventually you would end up with `/etc/step-ca/config/ca.json` like this:

```JavaScript
{
    "root": "/etc/step-ca/certs/root_ca.crt",
    "federatedRoots": null,
    "crt": "/etc/step-ca/certs/intermediate_ca.crt",
    "key": "/etc/step-ca/secrets/intermediate_ca_key",
    "address": ":8443",
    "insecureAddress": ":8080",
    "crl": {
        "enabled": true,
        "generateOnRevoke": true,
        "idpURL": "http://openwrt.lan:8080/crl"
    },
    "dnsNames": [
            "openwrt.lan",
            "192.168.1.1"
    ],
    "logger": {
            "format": "text"
    },
    "db": {
            "type": "badgerv2",
            "dataSource": "/etc/step-ca/db",
            "badgerFileLoadingMode": ""
    },
    "authority": {
            "provisioners": [
                    {
                            "type": "JWK",
                            "name": "JWK@openwrt.lan",
                            "claims": {
                                "maxTLSCertDuration": "8765h"
                            },
                            "key": {...},
                            "encryptedKey": "...",
                            "options": {
                                    "x509": {
                                        "templateFile": "/etc/step-ca/templates/x509/leaf-crl.tpl"
                                    }
                                }
                    },
                    {
                            "type": "ACME",
                            "name": "ACME@openwrt.lan",
                            "claims": {
                                    "enableSSHCA": true,
                                    "disableRenewal": false,
                                    "allowRenewalAfterExpiry": false,
                                    "disableSmallstepExtensions": false,
                                    "maxTLSCertDuration": "48h",
                                    "defaultTLSCertDuration": "48h"
                            },
                            "options": {
                                    "x509": {
                                        "templateFile": "/etc/step-ca/templates/x509/leaf-crl.tpl"
                                    },
                                    "ssh": {}
                            }
                    }
            ],
            "template": {
                "Country": "AQ",
                "Province": "South Pole",
                "Locality": "Amundsen-Scott South Pole Station",
                "Organization": "Homelab",
                "OrganizationalUnit": "Homelab cluster"
                },
            "backdate": "1m0s"
    },
    "tls": {...},
    "commonName": "Step Online CA"
}
```

Do not forget to restart the service:

```bash
# /etc/init.d/step-ca restart
```

The quickest way to check if `X509v3 CRL Distribution Points:` is now present on our certificates is to generate a certificate for LuCi webUI:

```bash
$ step ca certificate openwrt.lan \
/etc/uhttpd.crt /etc/uhttpd.key \
--san openwrt.lan \
--not-after=8765h

✔ Provisioner: JWK@openwrt.lan (JWK) [kid: sNXCP0f2uaMH3Nvj9wFHPwzQiSxQfSKVwLqO_73kstE]
Please enter the password to decrypt the provisioner key:
✔ CA: https://openwrt.lan:8443
✔ Would you like to overwrite /etc/uhttpd.crt [y/n]: y
✔ Would you like to overwrite /etc/uhttpd.key [y/n]: y
✔ Certificate: /etc/uhttpd.crt
✔ Private Key: /etc/uhttpd.key
```

reload uhttpd

```bash
# /etc/init.d/uhttpd restart  
```

and check if the issue went away

```powershell
C:\>curl -I https://openwrt.lan:443
HTTP/1.1 200 OK
```
